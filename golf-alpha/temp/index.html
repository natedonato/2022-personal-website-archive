<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>NateGolf</title>
  <link href="https://fonts.googleapis.com/css?family=Gloria+Hallelujah&display=block" rel="stylesheet" />
  <script src="./matter.js"></script>
  <script src="./rough.js"></script>
  <script src="./decomp.js"></script>
  <script src="./seedrandom.min.js">
  </script>

  <style>
    * {
      box-sizing: border-box;
    }

    body,
    html {
      /* overflow: hidden; */
      height: 100%;
      /* margin: 5px; */
      margin-bottom: 100px;
    }

    .canvas-container {
      position: relative;
      display: block;
      margin: 2vh auto;
      margin-top: calc(50vh - 45vmin);
      max-width: min(100%, 90vmin, 800px);
      max-height: min(100%, 90vmin, 800px);
      width: auto;
      height: auto;
    }

    #canvas-overlay {
      /* display: none; */
      position: absolute;

      top: 0;
      bottom: 0;
      left: 0;
      right: 0;
    }

    #tutorial {
      display: none;
      text-align: center;
      width: 100%;
      height: 100%;
      background: rgba(255, 255, 255, 1);
      padding: 5%;
      border: 1px solid #cccccc;
      line-height: 2.5vmin;
    }

    #back {
      cursor: pointer;
    }

    #back:hover {
      opacity: 0.8
    }

    #splash {
      width: 100%;
      height: 100%;
      background: rgba(255, 255, 255, 0.9);
      padding: 5%;

    }

    .vid {
      width: 70%;
      height: auto;
      border: 1px dashed blue
    }

    .menubutton:hover {
      cursor: pointer;
      fill: green;
    }

    canvas {
      /* display: block;
    margin: 2vh auto;
    max-width: min(100%, 90vw, 800px);
    max-height: min(100%, 90vmin); */
      width: 100%;
      height: auto;
      border: 1px solid black;
    }
  </style>

</head>

<body>

  <div class="canvas-container">
    <canvas id="canvas"></canvas>
  </div>
  Mode: <select name="mode" id="mode">
    <option value="draw">draw</option>
    <option selected value="edge">edge</option>
    <option value="pick">edit</option>
    <option value="flag">Flag</option>
  </select>
  <br>
  <button onclick="writeObject()"> Create </button>
  <br>
  Static? <input checked type="checkbox" id="static">
  <br>
  <button onclick="chaikinize()"> Round edges (adds many vertices) </button>
  <br>
  show debug outlines? <input type="checkbox" id="debug">
</body>

<script>
  // begin seed logic

  let seed = new Date();
  const urlParams = new URLSearchParams(window.location.search);

  let code = urlParams.get('date');
  if (code && code.length > 0) {
    seed = new Date(code * 1000)
  }

  let lastSeed = new Date();
  lastSeed.setTime(seed.getTime() - (24 * 60 * 60 * 1000));

  let rng = new Math.seedrandom(seed.toLocaleDateString("en"));
  let nateRand = () => rng.quick();

  // gets value between X and Y at A%
  const lerp = (x, y, a) => x * (1 - a) + y * a;

  // clamps A to within bounds
  const clamp = (a, min = 0, max = 1) => Math.min(max, Math.max(min, a));

  // look up what percentage between X and Y value A is found at
  const invlerp = (x, y, a) => clamp((a - x) / (y - x));

  // given range x1y1, and second range x2y2, find where value A would lie if it was on the second range
  const range = (x1, y1, x2, y2, a) => lerp(x2, y2, invlerp(x1, y1, a));


  // utility functions
  function between(min, max) {
    return Math.floor(nateRand() * (max + 1 - min) + min);
  }

  function dist(bod1, bod2) {
    return Math.sqrt((bod1.position.x - bod2.position.x) ** 2 + (bod1.position.y - bod2.position.y) ** 2);
  }
  // end seed logic







  // begin Engine setup
  const Engine = Matter.Engine,
    Common = Matter.Common,
    Render = Matter.Render,
    // Runner = Matter.Runner,
    Bodies = Matter.Bodies,
    Body = Matter.Body,
    Composites = Matter.Composites,
    Composite = Matter.Composite,
    // MouseConstraint = Matter.MouseConstraint,
    Constraint = Matter.Constraint,
    Vector = Matter.Vector,
    Vertices = Matter.Vertices,
    Events = Matter.Events;
  Common.setDecomp(decomp);

  const engine = Engine.create();

  // end Engine setup

  let playing = false;





  // general level creation setup

  // setting level dimensions
  let width = 2400;
  let height = 2400;

  width = 2200;
  height = 2200;


  const canvas = document.getElementById('canvas');

  const rc = rough.canvas(canvas);

  let generator = rc.generator;

  /** @type {CanvasRenderingContext2D} */

  ctx = canvas.getContext('2d');
  canvas.width = width;
  canvas.height = height;

  ctx.lineWidth = 1;
  ctx.strokeStyle = '#ff0';
  ctx.fillStyle = '#000';



  // make pagelines
  let lines = generator.rectangle(0, 0, canvas.width, canvas.height, { stroke: 'transparent', fill: "rgba(0, 0, 255, 0.29)", hachureAngle: 90, strokeWidth: 10, fillWeight: 5, hachureGap: 65, seed: between(0, 10000), roughness: 0.8 })

  //hidden canvas?
  const h_canvas = document.createElement('canvas');
  h_canvas.width = width;
  h_canvas.height = height;
  const h_ctx = h_canvas.getContext('2d');
  const h_rc = rough.canvas(h_canvas);

  //screenshot canvas
  const s_canvas = document.createElement('canvas');
  s_canvas.width = canvas.width;
  s_canvas.height = canvas.height;
  const s_ctx = s_canvas.getContext('2d');

  s_ctx.fillStyle = "white";
  s_ctx.fillRect(0, 0, canvas.width, canvas.height);

  let gs = [];


  function drawSpikes() {
    let w = width / 60;

    h_ctx.fillStyle = "red"

    height = height + w;
    for (let i = 0; i * w < width; i++) {

      h_ctx.beginPath();
      h_ctx.moveTo(w * i, height);
      if (!spikeHeights[i]) {
        spikeHeights[i] = between(25, 30) / 10 * w
      }

      h_ctx.lineTo(w * i + w / 2, height - spikeHeights[i]);
      h_ctx.lineTo(w * i + w, height);
      h_ctx.fill()



    }
    height = height - w;


  }


  let hidespikes = true;

  function redrawBg(death) {
    h_ctx.clearRect(0, 0, width, height);
    h_rc.draw(lines)
    if(!hidespikes){
      drawSpikes();
    }


    // plot past points
    h_ctx.fillStyle = "rgba(0, 0, 0, 0.2)";
    pastPoints.forEach(line => {
      line.forEach(point => {
        h_ctx.beginPath();
        h_ctx.arc(point.x, point.y, 4, 2 * Math.PI, false);
        h_ctx.fill()
      })
    })

  }

  let spikeHeights = [];
  let points = [];
  let pastPoints = [];
  let pastDeaths = [];
  let scribbles = [];
  let strokes = 0;
  let totalStrokes = 0;
  let currentHole = 0;
  let sunk = false;

  redrawBg();


  function render() {
    let currTime = new Date();
    fps = 1000 / (currTime - prevTime);
    prevTime = currTime;

    // clear previous
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.drawImage(h_canvas, 0, 0)


    ctx.strokeStyle = "black"
    ctx.lineWidth = 1

    // get bodies
    let bodies = Composite.allBodies(engine.world);


    // draw editing/shape in progress
    if (vertices[0]) {


      // draw lines
      ctx.beginPath(); // Start a new path
      ctx.moveTo(vertices[0].x, vertices[0].y); // Move the pen to (30, 50)
      ctx.lineWidth = 5;

      ctx.setLineDash([5, 5]);


      vertices.forEach(vertex => {
        ctx.lineTo(vertex.x, vertex.y); // Draw a line to (150, 100)
      })
      ctx.lineTo(vertices[0].x, vertices[0].y); // Draw a line to (150, 100)
      ctx.stroke(); // Render the path


      // draw points
      ctx.setLineDash([]);
      vertices.forEach(vertex => {
        ctx.beginPath();
        ctx.arc(vertex.x, vertex.y, 10, 0, 2 * Math.PI);
        ctx.stroke();
      })

    }


    // draw finished custom shapes
    bodies.forEach(nextBody => {
      if (nextBody.render.type === "shape") {
        let id = nextBody.render.id;
        let parts = nextBody.parts
        let outerVertices = []

        if (gs[id] === undefined) {
          let g = generator.polygon(nextBody.render.points.map(el => [el.x, el.y]), {
            stroke: nextBody.render.stroke, strokeWidth: 3,
            // fill: nextBody.render.fill,
            fill: nextBody.render.fill,
            seed: between(1, 99999)
          });
          gs[id] = g
        }

        let offset = [nextBody.position.x - nextBody.render.center.x, nextBody.position.y - nextBody.render.center.y]


        // handle rotations
        ctx.save();
        ctx.translate(nextBody.position.x, nextBody.position.y);
        ctx.rotate(nextBody.angle);
        ctx.translate(-nextBody.position.x, -nextBody.position.y);
        ctx.translate(...offset)
        rc.draw(gs[id]);
        ctx.setTransform(1, 0, 0, 1, 0, 0);



        // debug

        if(document.getElementById('debug').checked === true){

          nextBody.parts.forEach((part, idx) => {
            let g2 = generator.polygon(part.vertices.map(el => [el.x, el.y]), {
              stroke: nextBody.render.stroke, strokeWidth: 3,
              fill: idx === 0 && parts.length > 1 ? "rgba(0,0,255,0.1)" : "rgba(0,0,255,0.5)",
              fillStyle: "solid",
              seed: 1,
            });
            rc.draw(g2);
          })

        ctx.fillStyle = "blue"
        ctx.fillRect(nextBody.position.x, nextBody.position.y, 20, 20)
        ctx.fillStyle = 'green'
        ctx.fillRect(nextBody.render.center.x, nextBody.render.center.y, 10, 10)
        }


        // debugger;
        // }



      }
    })

    if(flagPos){
      rc.line(flagPos[0], flagPos[1], flagPos[0], flagPos[1] - 200, { strokeWidth: 3 })

      rc.polygon(
        [
          [flagPos[0], flagPos[1] - 200],
          [flagPos[0] + 80, flagPos[1] - 170],
          [flagPos[0], flagPos[1] - 140]
        ], {
        strokeWidth: 3,
        fill: !sunk ? 'rgba(255,0,0,0.7)' : 'green',
        fillStyle: "solid",
      }
      )
        // }
    }



    // for (let i = 0; i < bodies.length; i += 1) {
    //   let nextBody = bodies[i];
    //   ctx.beginPath();
    //   let vertices = bodies[i].vertices;




    //   if (nextBody.render.track === true) {
    //     let center = Vertices.centre(vertices);
    //     if (points.length < 1) {
    //       points.push(center);
    //     }
    //     let dist = Math.sqrt((center.x - points[points.length - 1].x) ** 2 + (center.y - points[points.length - 1].y) ** 2);

    //     let unitV = [center.x - points[points.length - 1].x, center.y - points[points.length - 1].y].map(el => el / dist)

    //     while (dist >= 15) {

    //       let nextPoint = {}
    //       nextPoint.x = unitV[0] * 15 + points[points.length - 1].x
    //       nextPoint.y = unitV[1] * 15 + points[points.length - 1].y
    //       points.push(nextPoint);
    //       dist = Math.sqrt((center.x - points[points.length - 1].x) ** 2 + (center.y - points[points.length - 1].y) ** 2);

    //       h_ctx.fillStyle = "black";
    //       h_ctx.beginPath();
    //       h_ctx.arc(nextPoint.x, nextPoint.y, 4, 2 * Math.PI, false);
    //       h_ctx.fill()
    //       // dist = Math.sqrt((center.x - points[points.length - 1].x) ** 2 + (center.y - points[points.length - 1].y) ** 2);

    //     }
    //   }




    //   if (nextBody.render.type === "detector") {
    //     //dont render
    //     // let id = nextBody.render.id;

    //     // if (gs[id] === undefined) {
    //     //     let g = generator.polygon(vertices.map(el => [el.x, el.y]), {
    //     //     stroke: "black", 
    //     //     strokeWidth: 3,
    //     //     fillWeight: 4,
    //     //     // fill: nextBody.render.fill,
    //     //     fill: "#13331b",
    //     //     fillStyle: nextBody.render.fillStyle,
    //     //     seed: between(1, 99999)
    //     //   });

    //     //   gs[id] = g;
    //     // }

    //     // rc.draw(gs[id]);

    //   } else if (nextBody.render.type === "ground") {
    //     let id = nextBody.render.id;

    //     if (gs[id] === undefined) {
    //       let g = generator.polygon(vertices.map(el => [el.x, el.y]), {
    //         stroke: nextBody.render.stroke, strokeWidth: 3,
    //         fill: nextBody.render.fill,
    //         fillStyle: nextBody.render.fillStyle,
    //         seed: between(1, 99999)
    //       });

    //       gs[id] = g;
    //     }

    //     rc.draw(gs[id]);

    //   } else if (nextBody.render.type === "hole") {

    //     let id = nextBody.render.id;

    //     if (gs[id] === undefined) {
    //       let g = generator.polygon(holeVertices.map(el => [el.x, el.y]), {
    //         stroke: nextBody.render.stroke,
    //         strokeWidth: 3,
    //         fill: nextBody.render.fill,
    //         fillStyle: nextBody.render.fillStyle,
    //         seed: between(1, 99999)
    //       });

    //       gs[id] = g;
    //     }

    //     rc.draw(gs[id]);

    //     // draw flag

    //     let slope = (holeVertices[5].y - holeVertices[4].y) / (holeVertices[5].x - holeVertices[4].x)
    //     let flagPos = [holeVertices[4].x + 5, holeVertices[4].y + 5 * slope];
    //     rc.line(flagPos[0], flagPos[1], flagPos[0], flagPos[1] - 200, { strokeWidth: 3 })

    //     rc.polygon(
    //       [
    //         [flagPos[0], flagPos[1] - 200],
    //         [flagPos[0] + 80, flagPos[1] - 170],
    //         [flagPos[0], flagPos[1] - 140]
    //       ], {
    //       strokeWidth: 3,
    //       fill: !sunk ? 'rgba(255,0,0,0.7)' : 'green',
    //       fillStyle: "solid",
    //     }
    //     )
    //     // }
    //   } else {




    //     // ball


    //   }

    // }


    // draw ball
    // ctx.fillStyle = 'black';
    // ctx.strokeStyle = 'black'
    // ctx.lineWidth = 3;
    // let vertices = ball.vertices;
    // ctx.beginPath();
    // ctx.moveTo(vertices[0].x, vertices[0].y);
    // for (let j = 1; j < vertices.length; j += 1) {
    //   ctx.lineTo(vertices[j].x, vertices[j].y);
    // }
    // ctx.lineTo(vertices[0].x, vertices[0].y);
    // ctx.closePath();
    // ctx.fill();
    // ctx.stroke();

    // if (ball.position.y > height - width / 30 || ball.position.x < 0 || ball.position.x > width) {


    //   reset();
    // }


    //text
    if (playing) {
      ctx.fillStyle = "black";
      ctx.font = '52px Gloria Hallelujah'
      ctx.fillText(
        `Hole ${currentHole} / 9. Current strokes: ${strokes}`,
        100, 100
      )
      let lives = ""

      ctx.fillStyle = "red";
      ctx.font = '82px Gloria Hallelujah'
      ctx.fillText(`${"♡".repeat(attempts - 1)}${"♥".repeat(5 - attempts + 1)}`, width - 500, 120)
      // ctx.strokeStyle = "black";
      // ctx.strokeText(`${"♡".repeat(attempts-1)}${"♥".repeat(5-attempts+1)}`,width - 500,120)

      if (fps >= 50) {
        ctx.fillStyle = "green";
      } else if (fps >= 40) {
        ctx.fillStyle = "yellow"
      } else {
        ctx.fillStyle = "red"
      }

      // ctx.fillText(
      //   `fps: ${Math.floor(fps)}`,
      //   100, 200
      // )
    } else {
      // end screen stuff?

    }


    // aim line arrow
    // if (clickPos.x !== null && mousePos.x !== null && playing) {
    //   let dist = Math.sqrt((clickPos.x - mousePos.x) ** 2 + (clickPos.y - mousePos.y) ** 2);
    //   let max = 400

    //   if (dist > max) {
    //     dist = max;
    //   }

    //   dist = (dist) / max

    //   let angle = -Math.atan2(clickPos.y - mousePos.y, clickPos.x - mousePos.x)
    //   let x = Math.cos(angle);
    //   let y = Math.sin(angle);
    //   x = x * 500.0 * dist
    //   y = y * 500.0 * dist
    //   let arrowL = 50
    //   let p2x = arrowL * Math.cos(angle + 4 * Math.PI / 5)
    //   let p2y = arrowL * Math.sin(angle + 4 * Math.PI / 5)
    //   let p3x = arrowL * Math.cos(angle + 6 * Math.PI / 5)
    //   let p3y = arrowL * Math.sin(angle + 6 * Math.PI / 5)

    //   ctx.beginPath();
    //   ctx.strokeStyle = "red"
    //   if (bombCount < 1) {
    //     ctx.strokeStyle = "grey"
    //   }
    //   // rc.line(clickPos.x, clickPos.y, clickPos.x + x, clickPos.y - y,{stroke: ctx.strokeStyle, strokeWidth: 5, roughness: 1})
    //   // rc.line(clickPos.x + x + p2x, clickPos.y - y - p2y, clickPos.x + x, clickPos.y - y,{stroke: ctx.strokeStyle, strokeWidth: 5, roughness: 1})
    //   // rc.line(clickPos.x + x + p3x, clickPos.y - y - p3y, clickPos.x + x, clickPos.y - y,{stroke: ctx.strokeStyle, strokeWidth: 5, roughness: 1})

    //   rc.line(ball.position.x, ball.position.y, ball.position.x + x, ball.position.y - y, { stroke: ctx.strokeStyle, strokeWidth: 5, roughness: 1 })
    //   rc.line(ball.position.x + x + p2x, ball.position.y - y - p2y, ball.position.x + x, ball.position.y - y, { stroke: ctx.strokeStyle, strokeWidth: 5, roughness: 1 })
    //   rc.line(ball.position.x + x + p3x, ball.position.y - y - p3y, ball.position.x + x, ball.position.y - y, { stroke: ctx.strokeStyle, strokeWidth: 5, roughness: 1 })



    // }


  }





  let currentTime = performance.now();
  let physicsBuffer = 0;
  let physicsStep = 16;
  let prevTime = new Date();
  let fps = 0;

  function gameLoop() {
    if (currentHole < 10) {
      //get time in ms since last frame
      let newTime = performance.now();
      let frameTime = newTime - currentTime;
      currentTime = newTime;

      // add time since last frame to physics buffer
      physicsBuffer += frameTime;

      while (physicsBuffer >= physicsStep) {
        Engine.update(engine, physicsStep);
        physicsBuffer -= physicsStep;

        // t += physicsStep;
        // console.log(steps)
      }

      // Engine.update(engine, 1000 / 60);
      render()

      window.requestAnimationFrame(gameLoop);
    }
  }
  window.requestAnimationFrame(gameLoop);

  function getMousePos(canvas, evt) {
    let rect = canvas.getBoundingClientRect();

    return {
      x: ((evt.clientX || evt.targetTouches[0].pageX) - rect.left) / (rect.right - rect.left) * canvas.width,
      y: ((evt.clientY || evt.targetTouches[0].pageY) - rect.top) / (rect.bottom - rect.top) * canvas.height
    };
  }


  let vertices = [];
  let selection = document.getElementById('mode')
  let flagPos = null;

  // edge creation mode
  canvas.addEventListener("mousedown", (e) => {
    if(selection.value === 'edge'){
      e.preventDefault();
      clickPos = getMousePos(canvas, e);
      // console.log("mouseDown", clickPos)
      vertices.push(clickPos)
      canvas.style.cursor = "pointer";
    }
  });

  canvas.addEventListener("mousedown", (e) => {
    if(selection.value === 'flag'){
      e.preventDefault();
      clickPos = getMousePos(canvas, e);
      flagPos = [clickPos.x, clickPos.y];
    }
  });


  // drawing mode
  let drawing = false;
  canvas.addEventListener("mousedown", (e) => {
    if(selection.value === 'draw'){
      e.preventDefault();
      clickPos = getMousePos(canvas, e);
      // console.log("mouseDown", clickPos)
      vertices.push(clickPos);
      canvas.style.cursor = "pointer";

      drawing = true;
    }
  })
  canvas.addEventListener("mousemove", (e) => {
    if(selection.value === 'draw' && drawing === true){

        vertices.push(getMousePos(canvas, e));
      }
    }
  )

    document.addEventListener("mouseup", (e) => {
        if (selection.value === 'draw') {
        drawing = false;  
    }
  })





  function writeObject(e) {
    if (vertices.length > 0) {
  
      let center = Matter.Vertices.centre(vertices)

      let newPlat = Bodies.fromVertices(center.x, center.y, vertices, {
        isStatic: document.getElementById('static').checked === true,
        render: {
          type: "shape",
          points: vertices,
          center: {},
          fill: `hsl(${Math.random() * 360}, 100%, 40%)`,
          id: crypto.randomUUID(),
        }
      }, 
      true,
      0.0001,
      50,
      0.01
      );

      if (!newPlat) { alert('error'); vertices = []; return; }

      let minX = Math.min(...vertices.map(el => el.x));
      let minY = Math.min(...vertices.map(el => el.y));

      let offset = { x: minX - newPlat.bounds.min.x, y: minY - newPlat.bounds.min.y };
      console.log(offset);  

      Body.translate(newPlat, offset);
      newPlat.render.center.x = newPlat.position.x
      newPlat.render.center.y = newPlat.position.y


      Composite.add(engine.world, [
        newPlat
      ]);

      vertices = [];
    }
  }


  function chaikinize(){
    if(!vertices){return};

    vertices = vertices.map(el => [el.x, el.y]);

    vertices = chaikin(vertices,1);
    vertices = vertices.map(el => {return({x: el[0], y: el[1]})});

  }

  function chaikin(arr, num) {
      if (num === 0) return arr;
      const l = arr.length;
      const smooth = arr.map((c, i) => {
        return [
          [0.75 * c[0] + 0.25 * arr[(i + 1) % l][0], 0.75 * c[1] + 0.25 * arr[(i + 1) % l][1]],
          [0.25 * c[0] + 0.75 * arr[(i + 1) % l][0], 0.25 * c[1] + 0.75 * arr[(i + 1) % l][1]]
        ];
      }).flat();
      return num === 1 ? smooth : chaikin(smooth, num - 1);
    }


</script>


</html>