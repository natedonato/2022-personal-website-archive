<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Matter.js proj</title>
      <link href="https://fonts.googleapis.com/css?family=Gloria+Hallelujah&display=block" rel="stylesheet" />
  <script src="./matter.js"></script>
  <script src="./rough.js"></script>
  <script src="./decomp.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/seedrandom/3.0.5/seedrandom.min.js">
</script>
</head>

<body>

  <div id="date"></div>
  <a id="yesterday">yesterday's game</a>

</body>

<script>

  let seed = new Date();
    const urlParams = new URLSearchParams(window.location.search);

    let code = urlParams.get('date');
    if (code && code.length > 0) {
      seed = new Date(code * 1000)
    }

    let lastSeed = new Date();
    lastSeed.setTime(seed.getTime() - (24 * 60 * 60 * 1000));

    let rng = new Math.seedrandom(seed.toLocaleDateString("en"));
    document.getElementById('date').textContent = seed.toLocaleDateString("en");

    document.getElementById('yesterday').setAttribute("href", `?date=${parseInt(lastSeed.getTime() / 1000).toFixed(0)}`)

    let nateRand = () => rng.quick();




  function between(min, max) {
    return Math.floor(nateRand() * (max + 1 - min) + min);
  }

  // module aliases

  let playing = true;

  const Engine = Matter.Engine,
    Common = Matter.Common,
    Render = Matter.Render,
    Runner = Matter.Runner,
    Bodies = Matter.Bodies,
    Body = Matter.Body,
    Composites = Matter.Composites,
    Composite = Matter.Composite,
    // MouseConstraint = Matter.MouseConstraint,
    Constraint = Matter.Constraint,
    Vector = Matter.Vector,
    Vertices = Matter.Vertices,
    Events = Matter.Events;
    Common.setDecomp(decomp);

  // create an engine
  const engine = Engine.create();
  engine.timing.timescale = 0.4

  // let stack = Composites.stack(350, 355, 10, 6, 0, 0, function(x, y) {
  //       return Bodies.rectangle(x, y, 30, 30);
  //   });

  // let ground = Bodies.rectangle(200, 1000, 300, 50, {
  //  isStatic: true,
  //  render: {
  //   id: 1,
  //   fill: null,
  //   stroke: 'red',
  //   fillStyle: 'none',
  //   type: "ground"
  // }});


  // let ground2 = Bodies.rectangle(800, 1100, 300, 50, {
  //  isStatic: true,
  //  render: {
  //   id: 2,
  //   fill: null,
  //   stroke: 'red',
  //   fillStyle: 'none',
  //   type: "ground"
  // }});

  // let ground3 = Bodies.rectangle(1100, 1500, 300, 50, {
  //  isStatic: true,
  //  render: {
  //   id: 3,
  //   fill: null,
  //   stroke: 'red',
  //   fillStyle: 'none',
  //   type: "ground"
  // }});


  // let ground4 = Bodies.rectangle(1100, 600, 300, 50, {
  //  isStatic: true,
  //  render: {
  //   id: 4,
  //   fill: null,
  //   stroke: 'red',
  //   fillStyle: 'none',
  //   type: "ground"
  // }});




  let nid = 10;
  let width = 1600;
  let height = 2400;

  function randomGround() {
    let w = between(250, 450)
    let h = between(50, 90);
    let y = between(400, height - 200)
    let x = between(w / 2 + 100, width - w / 2 - 100)
    nid += 1;

    return Bodies.rectangle(x, y, w, h, {
      isStatic: true,
      render: {
        id: nid,
        fill: null,
        stroke: 'red',
        fillStyle: 'none',
        type: "ground"
      }
    });
  }
  let holeVertices;

  function hole(){

    let w = between(350, 550)
    let h = between(140, 240);

    let holeW = between(55, 85)
    let holeH = between(75,85)
    let edge = 50;

    let holeX = between(edge, w-holeW - edge);

    let slightOffset = 15;

    let mediumOffset = 50;

    let corners = [{x: 0, y: between(-slightOffset, slightOffset),},
    {x: holeX, y: 0},
    {x: holeX, y: holeH + between(0,slightOffset)},
    {x: holeX + holeW, y: holeH + between(0,slightOffset)} ,
    {x: holeX+holeW, y: between(-slightOffset, slightOffset)},
    {x: w + between(-mediumOffset, mediumOffset), y: between(-slightOffset, slightOffset),},
    {x: w + between(-mediumOffset, mediumOffset),y:h + between(-slightOffset, slightOffset)},
    {x: 0 + between(-mediumOffset, mediumOffset), y: h}
  ];

  holeVertices = corners;

  let myHole = Bodies.fromVertices(0,0, holeVertices,{ isStatic: true, render:{type: "hole"}})
    return myHole;
  }

  let platforms = [];
  for (let i = 0; i < between(4, 12); i++) {
    platforms.push(randomGround());
  }

  platforms = platforms.sort((a, b) => a.position.x - b.position.x)


  function dist(bod1, bod2) {
    return Math.sqrt((bod1.position.x - bod2.position.x) ** 2 + (bod1.position.y - bod2.position.y) ** 2);
  }
  function checkOverlap(radius, Xc, Yc, rect) {

    let X1 = rect.bounds.min.x;
    let X2 = rect.bounds.max.x;

    let Y1 = rect.bounds.min.y;
    let Y2 = rect.bounds.max.y;



    // Find the nearest point on the
    // rectangle to the center of
    // the circle
    let Xn = Math.max(X1, Math.min(Xc, X2));
    let Yn = Math.max(Y1, Math.min(Yc, Y2));

    // Find the distance between the
    // nearest point and the center
    // of the circle
    // Distance between 2 points,
    // (x1, y1) & (x2, y2) in
    // 2D Euclidean space is
    // ((x1-x2)**2 + (y1-y2)**2)**0.5
    let Dx = Xn - Xc;
    let Dy = Yn - Yc;
    return (Dx * Dx + Dy * Dy) <= radius * radius;
  }



  let overlap = true;
  let Cx = platforms[0].position.x
  let Cy = platforms[0].position.y - 10;
  let rad = 10;


  // replace this with a better function that generates a start and finish, and deletes any platforms in their "airspace"
  while (overlap) {
    overlap = false;
    platforms.forEach(plat => {
      if (checkOverlap(rad + 5, Cx, Cy - 5, plat) === true) {
        Cy = plat.bounds.min.y - rad - 0.01;
        overlap = true;
      }
    })
  }

  let ball = Bodies.circle(Cx, Cy - rad, rad, {
    restitution: 0.4,
    density: 0.004,
    render: {
      track: true,
      type: "ball",
      fillStyle: "blue"
    }
  })


  platforms = platforms.sort((a, b) => dist(a, ball) - dist(b, ball))
  platforms[0].render.fill = "orange";


  const myHole = hole();


  Body.setPosition(myHole, platforms[platforms.length - 1].position);


  let min = [...holeVertices].sort((a,b) => a.x - b.x)[0]
  let min2 = [...myHole.vertices].sort((a,b) => a.x - b.x)[0]
  

  let offsetY = min.y - min2.y
  let offsetX = min.x - min2.x
  
  holeVertices = holeVertices.map(el => ({x: el.x - offsetX, y: el.y - offsetY }));

  let offsetY2 = holeVertices[1].y - myHole.position.y
  let offsetX2 = holeVertices[1].x - myHole.position.x

  let detector = Bodies.fromVertices(0, 0, [holeVertices[1], holeVertices[2], holeVertices[3], holeVertices[4]],{ isStatic: true, isSensor: true, render: {type: 'detector'}})

    let centre = Vertices.centre([holeVertices[1], holeVertices[2], holeVertices[3], holeVertices[4]]);
      Body.setPosition(detector, {
        x: detector.position.x + centre.x,
        y: detector.position.y + centre.y
      });

  platforms.pop();
  myHole.render.fill = "green";


  function reset() {
    Body.setVelocity(ball, { x: 0, y: 0 })
    Body.setPosition(ball, { x: Cx, y: Cy })
    pastPoints = pastPoints.concat(points);
    points = []
    redrawBg();
    attempts += 1;
  }

  // add all of the bodies to the world
  Composite.add(engine.world, [
    // stack, boxA, boxB,
    // ground, 
    // ground2, 
    // ground3,
    // ground4,
    ...platforms,
    ball,
    myHole,
    detector
    // Constraint.create({
    //   bodyA: ground,
    //   pointB: Vector.clone(ground.position),
    //   stiffness: 1,
    //   length: 0,
    //   render: {
    //     fillStyle: "black",
    //     strokeStyle: "black",
    //     lineWidth: 0,
    //   }
    // })
  ]);

  // const renderInst = Render.create({
  //   width: width,
  //   height: height,
  //   element: document.body,
  //   engine: engine,
  //   options: {
  //     wireframes: false,
  //     background: 'transparent',
  //     pixelRatio: 2,
  //     width: width,
  //     height: height,
  //     // showShadows: true,
  //   }
  // });

  // // run the renderer
  // Render.run(renderInst);

  //    Render.lookAt(renderInst, {
  //       min: { x: 0, y: 0 },
  //       max: { x: 1600, y: 1600 }
  //     });


  // create runner
  let runner = Runner.create({ isFixed: true });
  // runner.isFixed = true;

  // run the engine
  Runner.run(runner, engine);


  /** @type {HTMLCanvasElement} */
  const canvas = document.createElement('canvas');
  const rc = rough.canvas(canvas);

  let generator = rc.generator;
  let gs = {};


  ctx = canvas.getContext('2d');
  canvas.width = width;
  canvas.height = height;
  document.body.appendChild(canvas);

  ctx.lineWidth = 1;
  ctx.strokeStyle = '#ff0';
  ctx.fillStyle = '#000';

  let points = [];
  let pastPoints = [];
  let scribbles = [];
  let strokes = 0;

  let attempts = 1;

  let clicks = [];


   // make pagelines
    let lines = generator.rectangle(0, 0, canvas.width, canvas.height, { fill: "rgba(0, 0, 255, 0.39)", hachureAngle: 90, strokeWidth: 5, hachureGap: 65, seed: 5 })

    //hidden canvas?
  const h_canvas = document.createElement('canvas');
  h_canvas.width = width;
  h_canvas.height = height;
  const h_ctx = h_canvas.getContext('2d');
  const h_rc = rough.canvas(h_canvas);


  function redrawBg(){
    h_ctx.clearRect(0,0,width,height);
    h_rc.draw(lines)

    // plot past points
    h_ctx.fillStyle = "rgba(0, 0, 0, 0.2)";
    pastPoints.forEach(point => {
      h_ctx.beginPath();
      h_ctx.arc(point.x, point.y, 4, 2 * Math.PI, false);
      h_ctx.fill()
    })
  }
  redrawBg();

 
  let prevTime = new Date();
  let fps = 0;
  function render() {
    let currTime = new Date();
    fps = 1000 / (currTime - prevTime);
    prevTime = currTime;

    // clear previous
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.drawImage(h_canvas, 0,0)

    //draw bg lines
    // rc.draw(lines)


    // // plot current points
    // ctx.fillStyle = "black";
    // points.forEach(point => {
    //   // rc.circle(point.x, point.y, 20,{stroke: "blue", fill: "blue", roughness: 0.2, fillStyle: ""});
    //   ctx.beginPath();
    //   ctx.arc(point.x, point.y, 4, 2 * Math.PI, false);
    //   ctx.fill()
    // })



    ctx.strokeStyle = "black"
    ctx.lineWidth = 1

    // get bodies
    let bodies = Composite.allBodies(engine.world);

    for (let i = 0; i < bodies.length; i += 1) {
      let nextBody = bodies[i];
      ctx.beginPath();
      let vertices = bodies[i].vertices;




      if (nextBody.render.track === true) {
        let center = Vertices.centre(vertices);
        if (points.length < 1) {
          points.push(center);
        }
        let dist = Math.sqrt((center.x - points[points.length - 1].x) ** 2 + (center.y - points[points.length - 1].y) ** 2);
        if (dist > 9) {
          points.push(center);
          h_ctx.fillStyle = "black";
          h_ctx.beginPath();
          h_ctx.arc(center.x, center.y, 4, 2 * Math.PI, false);
          h_ctx.fill()
        }
      }




      if(nextBody.render.type ==="detector"){
        //dont render
      }else if (nextBody.render.type === "ground") {
        let id = nextBody.render.id;

        if (gs[id] === undefined) {
          let g = generator.polygon(vertices.map(el => [el.x, el.y]), {
            stroke: nextBody.render.stroke, strokeWidth: 3,
            fill: nextBody.render.fill,
            fillStyle: nextBody.render.fillStyle,
            seed: between(1, 99999)
          });

          gs[id] = g;
        }

        rc.draw(gs[id]);

      } else if(nextBody.render.type === "hole") {
        let id = nextBody.render.id;

        if (gs[id] === undefined) {
          let g = generator.polygon(holeVertices.map(el => [el.x, el.y]), {
            stroke: nextBody.render.stroke, strokeWidth: 3,
            fill: nextBody.render.fill,
            fillStyle: nextBody.render.fillStyle,
            seed: between(1, 99999)
          });

          gs[id] = g;
        }

        rc.draw(gs[id]);

        // draw flag

        let slope = (holeVertices[5].y-holeVertices[4].y) / (holeVertices[5].x - holeVertices[4].x)
        let flagPos = [ holeVertices[4].x + 5, holeVertices[4].y + 5 * slope ];
        rc.line(flagPos[0], flagPos[1], flagPos[0], flagPos[1] - 200, { strokeWidth: 3 })

        rc.polygon(
          [
          [flagPos[0], flagPos[1] - 200], 
          [flagPos[0] + 80, flagPos[1] - 170], 
          [flagPos[0], flagPos[1] - 140]
      ],{strokeWidth: 3,fill: 'rgba(255,0,0,0.7)', fillStyle: "solid", }
          )
        // }
      }else{
        ctx.fillStyle = 'black';
        ctx.strokeStyle = 'black'
        ctx.lineWidth = 3;

        ctx.beginPath();
        ctx.moveTo(vertices[0].x, vertices[0].y);
        for (let j = 1; j < vertices.length; j += 1) {
          ctx.lineTo(vertices[j].x, vertices[j].y);
        }
        ctx.lineTo(vertices[0].x, vertices[0].y);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
      }
    }


    if(ball.position.y > height || ball.position.x < 0 || ball.position.x > width){
      reset();
    }

    ctx.fillStyle = "black";
    ctx.font = '52px Gloria Hallelujah'
    ctx.fillText(
      `available hits: ${bombCount} total strokes: ${strokes} attempts: ${attempts}`,
      100,100
    )


    // aim line
    if(clickPos.x !== null && mousePos.x !== null){
    let dist = Math.sqrt((clickPos.x - mousePos.x) ** 2 + (clickPos.y - mousePos.y) ** 2);
    let max = 400

    if (dist > max) {
      dist = max;
    }

    dist = (dist) / max

    let angle = -Math.atan2(clickPos.y - mousePos.y, clickPos.x - mousePos.x)
    let x = Math.cos(angle);
    let y = Math.sin(angle);
    x = x * 500.0 * dist
    y = y * 500.0 * dist

    ctx.beginPath();
    ctx.strokeStyle = "red"
    if(bombCount < 1){
      ctx.strokeStyle = "grey"
    }
    ctx.lineWidth = 5;
    ctx.moveTo(ball.position.x, ball.position.y);
    ctx.lineTo(ball.position.x + x, ball.position.y - y);
    ctx.stroke();
    }

    //debug
    if(fps >= 50){
      ctx.fillStyle = "green";
    }else if(fps >= 40){
      ctx.fillStyle = "yellow"
    }else{
      ctx.fillStyle = "red"
    }

     ctx.fillText(
      `fps: ${Math.floor(fps)}`,
      100, 200
    )


    window.requestAnimationFrame(render);
  }


  window.requestAnimationFrame(render);

  let bombCount = 2;

  Events.on(engine, "collisionActive", (e) => {

    let pairs = e.pairs;
    // console.log(pairs)

    for(let i = 0; i < pairs.length; i++){
      if(bombCount < 2 && ball.velocity.x ** 2 < 0.001 && ball.velocity.y ** 2 < 0.001 && (pairs[i].bodyA.render?.type === 'ball' ||  pairs[i].bodyB.render?.type === 'ball')){
        bombCount = 2;
      }

      if ((pairs[i].bodyA.render?.type === 'detector' || pairs[i].bodyB.render?.type === 'detector') && (pairs[i].bodyA.render?.type === 'ball' || pairs[i].bodyB.render?.type === 'ball')) {
        if(ball.velocity.x ** 2 < 0.001 && ball.velocity.y ** 2 < 0.001 && playing){
          alert("you win!");

          playing = false;

          Runner.stop(runner);
        }
      }

    }
  })

  let clickPos = {x: null, y: null}
  let mousePos = {x: null, y: null}

  document.addEventListener("mousedown", (e) => {
      clickPos = getMousePos(canvas, e);
    // console.log("mouseDown", clickPos)
  });
  document.addEventListener("touchstart", (e) => {
        e.preventDefault();

      clickPos = getMousePos(canvas, e);
    // console.log("mouseDown", clickPos)
  }, { passive: false });

  document.addEventListener("mousemove",e=>{
    if(clickPos.x !== null){
      mousePos = getMousePos(canvas, e);
    }
  })

  document.addEventListener("touchmove",e=>{
    e.preventDefault();
    if(clickPos.x !== null){
      mousePos = getMousePos(canvas, e);
    }
  }, { passive: false })

  document.addEventListener("mouseup", 
    mouseUp
  )
  document.addEventListener("touchend", 
    mouseUp
  )

  function mouseUp(e){
    console.log('mouseup')

    // let mousePos = getMousePos(canvas, e);
    let ballPos = ball.position;
    let dist = Math.sqrt((clickPos.x - mousePos.x) ** 2 + (clickPos.y - mousePos.y) ** 2);
    let max = 400

    if (dist > max) {
      dist = max;
    }

    if (dist < 25) {
      dist = 25;
    }

    dist = (dist) / max

    let angle = -Math.atan2(clickPos.y - mousePos.y, clickPos.x - mousePos.x)


    let x = Math.cos(angle);
    let y = Math.sin(angle);

    x = x * 14 * 0.01 * dist
    y = y * 14 * 0.01 * dist

    if(bombCount > 0){

    Body.applyForce(ball, ball.position, { x: x, y: -y })
    strokes += 1;
    bombCount -= 1;
    }

    clickPos = {x: null,y: null}
    mousePos = {x: null,y: null}
    // scribbles.push(scribblePoints((ballPos.x - mousePos.x) / 2 + mousePos.x,(ballPos.y-mousePos.y) / 2 + mousePos.y, 140 * dist + 80, 80 * dist + 40))

  }

  //explosion scribbles, depricated
  function scribblePoints(x, y, size, num) {
    let points = [];

    let path = new Path2D();

    for (let i = 0; i < num; i++) {
      let point = { x: x + between(-size / 2, size / 2), y: y + between(-size / 2, size / 2) }
      points.push(point);
    }

    path.moveTo(points[0].x, points[0].y);

    for (let i = 1; i < points.length; i++) {
      path.lineTo(points[i].x, points[i].y);
    }

    return path;
  }

  // get relative coordinate of mouse 
  function getMousePos(canvas, evt) {
    let rect = canvas.getBoundingClientRect();
    
    return {
      x: (evt.clientX || evt.targetTouches[0].pageX - rect.left) / (rect.right - rect.left) * canvas.width,
      y: (evt.clientY || evt.targetTouches[0].pageY - rect.top) / (rect.bottom - rect.top) * canvas.height
    };
  }

</script>
<style>
  body,
  html {
    /* overflow: hidden; */
    height: 100%;
    /* margin: 5px; */
    margin-bottom: 100px;
  }


  canvas {
    display: block;
    margin: 5px auto;
    max-width: min(100%, 95vmin);
    max-height: min(100%, 95vmin);
    width: auto;
    height: auto;
    border: 1px solid black;
  }
</style>

</html>